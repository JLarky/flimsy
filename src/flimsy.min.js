var o,s,u=!1,a=Symbol(),r=class{static wrap(t,e,i){let p=s,b=u;s=e,u=i;try{return t()}catch(f){let d=e?.get(a);if(d)d.forEach(v=>v(f));else throw f}finally{s=p,u=b}}},c=class{constructor(t,{equals:e}={}){this.observers=new Set;this.get=()=>(u&&s instanceof l&&(this.observers.add(s),s.signals.add(this)),this.parent?.waiting&&this.parent.update(),this.value);this.set=t=>{let e=t instanceof Function?t(this.value):t;return this.equals(this.value,e)||(o?o.set(this,e):(this.value=e,this.stale(1),this.stale(-1))),this.value};this.stale=t=>{this.observers.forEach(e=>{e.stale(t)})};this.value=t,this.equals=e===!1?()=>!1:e||Object.is}},T=class{constructor(){this.parent=s;this.cleanups=[];this.contexts={};this.observers=new Set;this.signals=new Set;this.dispose=()=>{this.observers.forEach(t=>{t.dispose()}),this.signals.forEach(t=>{t.observers.delete(this)}),this.cleanups.forEach(t=>{t()}),this.cleanups=[],this.contexts={},this.observers=new Set,this.signals=new Set,this.parent?.observers.delete(this)};this.get=t=>t in this.contexts?this.contexts[t]:this.parent?.get(t);this.set=(t,e)=>{this.contexts[t]=e}}},h=class extends T{wrap(t){let e=()=>t(this.dispose);return r.wrap(e,this,!1)}},l=class extends T{constructor(e,i){super();this.waiting=0;this.run=()=>(this.dispose(),this.parent?.observers.add(this),r.wrap(this.fn,this,!0));this.update=()=>{this.waiting=0,this.signal.set(this.run())};this.stale=e=>{!this.waiting&&e<0||(this.waiting+=e,this.signal.stale(e),this.waiting||this.update())};this.fn=e,this.signal=new c(this.run(),i),this.signal.parent=this}};function g(n,t){let{get:e,set:i}=new c(n,t);return[e,i]}function w(n){new l(n)}function C(n,t){return new l(n,t).signal.get}function y(n){return new h().wrap(n)}function x(n){let t=Symbol();return{id:t,defaultValue:n,get:()=>s?.get(t)??n,set:p=>s?.set(t,p)}}function E(n){return n.get()}function S(n){s?.cleanups.push(n)}function k(n){var t;!s||((t=s.contexts)[a]||(t[a]=[]),s.contexts[a].push(n))}function F(n){if(o)return n();let t=o=new Map;try{return n()}finally{o=void 0,t.forEach((e,i)=>i.stale(1)),t.forEach((e,i)=>i.set(()=>e)),t.forEach((e,i)=>i.stale(-1))}}function O(n){return r.wrap(n,s,!1)}export{F as batch,x as createContext,w as createEffect,C as createMemo,y as createRoot,g as createSignal,S as onCleanup,k as onError,O as untrack,E as useContext};
